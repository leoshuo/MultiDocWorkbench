# 沉淀与 Replay 详细指南（后端管理端）

版本：1.6.4  
更新日期：2026-01-25

## v1.6.4 重要更新

### Replay 智能跳过机制

**新增**：当 Replay 无法找到符合录制要求的输入源信息时，返回 `pass` 状态而非强制执行

**行为说明**：
- **pass 状态**：业务级跳过，区别于系统级 `fail`
- **目标保护**：pass 时目标位置内容保持不变，不会被错误覆盖
- **原因展示**：在两个工作台都显示跳过原因（如"未找到有效输入源"、"目标标题不存在"等）

### 沉淀校验模式

**新增**：每个沉淀可设置校验模式

| 模式 | 标识 | 行为 |
|------|------|------|
| **强校验** | 🔒 | 要求找到与录制时相似的内容特征（前后文、摘要等），未找到则 pass |
| **不校验** | 🔓 | 不做严格校验，努力找到目标位置并执行（默认） |

**设置方式**：在沉淀编辑弹窗中选择校验模式

### 统一沉淀编辑

- **弹窗编辑**：点击沉淀的"✏️ 编辑"按钮，弹出完整编辑弹窗（复用结束沉淀时的确认弹窗）
- **移除内联编辑**：不再支持对单个 section 的内联编辑/编译
- **保存替换**：编辑保存后直接替换原沉淀记录

---

## v1.6.3 重要修复

### 应用端与后管端 Replay 统一性

**问题**：应用端点击按钮执行沉淀集 Replay 结果与后管端不一致

**根因**：
1. dispatch API 响应格式处理错误：应用端检查 `dispatchRes?.result`，但 API 返回 `{ summary, detail, edits, usedModel }`
2. insert_to_summary 输入获取逻辑不完整：扩写类操作应从当前大纲获取摘要作为输入

**修复**：
- 正确处理 dispatch API 响应的 `usedModel`、`detail`、`edits` 字段
- insert_to_summary 支持从当前大纲动态获取目标标题的摘要内容
- 统一目标标题定位：同时支持 `targetIds` 和 `targetTitles` 匹配

---

## 1. 沉淀记录

每条沉淀由多条 Section 组成，支持以下操作：

| 操作 | 说明 |
|------|------|
| 拖拽排序 | 直接拖拽调整执行顺序 |
| 点击编号 | 修改执行顺序 |
| 编辑内容 | 名称与各字段均可编辑 |
| 删除 | 直接删除数据库记录 |

## 2. Section 结构

每条 Section 包含五部分：

| 字段 | 说明 | 可标记 |
|------|------|--------|
| 输入来源 | 操作的输入数据来源 | 必须/可选 |
| 动作执行 | 执行的具体动作 | 必须/可选 |
| 执行摘要 | 执行结果摘要 | 必须/可选 |
| 记录位置 | 输出写入位置（使用标题而非序号） | 必须/可选 |
| 复现方式 | 特殊按钮的复现策略 | - |

### 编辑要求
- 可对"输入来源/动作执行/执行摘要/记录位置"标记【必须/可选】
- 支持回车确认编辑
- 编辑完成后（名称除外）需经过大模型编译为 Replay Meta
- 编译后自动持久化到 `data/precipitation-records.json`

## 3. Replay 机制

### Replay 级别
| 级别 | 说明 |
|------|------|
| 沉淀级 Replay | 按 Section 顺序依次执行 |
| Section级 Replay | 单条执行 |
| 沉淀集 Replay | 执行沉淀集内所有沉淀的所有 Section |

### 执行状态
| 级别 | 状态 | 说明 |
|------|------|------|
| Section | `done` | 完全成功 |
| Section | `pass` | 泛化妥协但完成 |
| Section | `fail` | 失败（必须记录原因） |
| 沉淀 | `done` | 所有 Section 成功 |
| 沉淀 | `partial done` | 部分成功 |
| 沉淀 | `fail` | 失败 |

## 4. 双重沉淀模式与双记录机制

### Section 双记录结构

每个 Section 同时保存两份记录：

| 记录类型 | 字段 | 说明 | 用途 |
|----------|------|------|------|
| **大模型记录** | `llmScript` | 用户确认的结构化脚本解析结果 | 大模型 Replay 时使用 |
| **脚本记录** | `originalScript` | 系统自动录制的原始参数 | 脚本回退 Replay 时使用 |

#### llmScript 字段
```json
{
  "title": "填入摘要",
  "type": "insert_to_summary",
  "description": "从文档中提取指定内容填入大纲摘要",
  "contentDescription": "需要提取人员姓名信息",
  "contextBefore": "内部 网络安全保卫总队",
  "contextAfter": "每日晨会要报",
  "targetTitle": "二、具体清查情况",
  "aiGuidance": "提取选区内容后去除职务称谓仅保留姓名"
}
```

#### originalScript 字段
```json
{
  "action": "填入摘要",
  "buttonLabel": "填入摘要",
  "content": "操作记录：将内容预览中框选的文本...",
  "meta": { /* 原始元数据 */ }
}
```

### 大模型沉淀（默认）
- 允许泛化，适应不同场景
- **优先使用 llmScript 进行智能 Replay**
- 依靠大模型理解脚本意图并智能执行
- 失败时自动回退到 originalScript 脚本执行
- 适合需要灵活处理的场景

### 脚本沉淀
- 严格一致，精确复现
- 直接使用 originalScript 执行
- 不一致直接 `pass` 并报错原因
- 适合需要精确控制的场景

### Replay 优先级
```
1. 大模型模式 + 有 llmScript
   → 尝试大模型执行
   → 成功：标记 llm_done
   → 失败：回退到脚本执行

2. 脚本执行（或回退）
   → 使用 originalScript 执行
   → 成功：标记 script_done
   → 失败：
     - 大模型模式：标记 skipped（两者都失败）
     - 脚本模式：标记 fail
```

### 执行状态与结果显示（v1.6.3 更新）

| 状态 | 显示格式 | 说明 |
|------|----------|------|
| `llm_done` | LLM Replay Done | 大模型成功执行 |
| `llm_done` (兼容) | LLM Replay Done（兼容性执行，差异：...） | 有差异但成功执行 |
| `script_done` | Script Replay Done | 脚本执行成功 |
| `script_fallback` | Script Replay Done（大模型回退原因：...） | 大模型失败后回退到脚本 |
| `skipped` | Skipped | 大模型和脚本都失败，跳过此步骤 |
| `fail` | Failed | 完全失败（仅脚本模式） |

**结果反馈原则**：
- 大模型完全成功：只显示"LLM Replay Done"
- 大模型兼容性执行：显示差异内容
- 回退到脚本：显示大模型失败原因

### 切换方式
- 每条沉淀可独立切换"脚本沉淀/大模型沉淀"模式
- 切换后立即生效

## 5. 自动沉淀流程

```
1. 点击"自动沉淀"开始录制
   |
   v
2. 执行各种操作（点击按钮）
   - 每次按钮点击自动生成 Section
   - Section 包含完整的输入、动作、输出信息
   |
   v
3. 点击"结束沉淀"
   - 生成沉淀记录
   - 保存到 data/precipitation-records.json
   |
   v
4. 可选：编辑沉淀记录
   - 调整顺序
   - 编辑字段
   - 编译为 Replay Meta
```

### 自动沉淀记录原则

**核心原则：只记录按钮的 Replay 逻辑，不记录编辑框中的具体内容**

例如：操作调度中点击"执行指令"按钮时：
- 不记录：文本框中输入的具体内容
- 只记录：点击"执行指令"按钮的相关重要信息

### Section 记录四要素

| 要素 | 说明 | 示例 |
|------|------|------|
| **输入来源** | 用户基于什么类型的内容操作 | 记录该部分内容的类型、上下文信息 |
| **动作执行** | 用户输入了什么要求 | 用户的修改意图和指令 |
| **记录位置** | 回写作用在什么地方 | **使用标题定位，而非序号**（如"写入'项目背景'标题下的摘要"） |
| **执行摘要** | 结果输出了什么 | 执行结果的摘要信息 |

### 位置记录规范
- 正确：记录写入"项目背景"标题下的摘要
- 错误：记录写入第3个标题下的摘要
- 原因：使用标题可确保 Replay 时定位准确，不受顺序变化影响

## 6. 沉淀集管理 沉淀集管理

### 入口
点击"沉淀集列表"打开沉淀集管理面板

### 功能
| 操作 | 说明 |
|------|------|
| 新增 | 创建新的沉淀集 |
| 更新 | 修改沉淀集内容 |
| 重命名 | 修改沉淀集名称 |
| 删除 | 删除沉淀集 |
| Replay | 执行沉淀集内所有沉淀 |

### 合并沉淀
- 选择多条沉淀合并到某个沉淀集
- 沉淀集内的每条沉淀仍可单独编辑与 Replay

## 7. 应用端与后管端架构设计

### 核心理念
```
应用端（多文档处理工作台）     后管端（经验沉淀工作台）
     ↓ 用户交互界面                    ↓ 配置和执行中心
     ↓ 收集用户需求                    ↓ 配置沉淀集
     ↓ 展示执行结果                    ↓ 配置目录路径
                                      ↓ 执行 Replay 逻辑
```

### 设计说明
- **应用端**：只是用户交互的界面，收集用户需求，展示结果
- **后管端**：真正执行所有自动化脚本和大模型 Replay 逻辑的地方
- **服务端**：处理 Replay 执行、文件加载、数据持久化

### Replay 执行流程
```
1. 用户在应用端点击按钮
   ↓
2. 应用端调用服务端 /api/multi/replay/execute API
   ↓
3. 服务端从配置的目录自动加载文件
   ↓
4. 服务端执行沉淀集中的所有 Replay 步骤
   ↓
5. 服务端返回执行结果和加载的文档
   ↓
6. 应用端同步显示文档列表和执行结果
```

## 8. 应用端按钮配置

### 配置界面
- 左列：前台按钮列表
- 右列：沉淀集列表（可多选）
- **Replay 目录配置**：配置服务端自动加载文件的目录路径

### 配置流程
1. 选择要配置的前台按钮
2. 勾选关联的沉淀集（支持多选）
3. **配置 Replay 目录路径**（服务端可访问的绝对路径）
4. 点击保存
5. 保存成功后前台按钮即可触发对应沉淀集 Replay

### 目录配置说明
| 配置项 | 说明 |
|--------|------|
| 目录路径 | 服务端可访问的绝对路径（如 `C:\Documents` 或 `/home/user/docs`） |
| 自动加载 | Replay 时自动从目录读取文件 |

### 默认按钮
| 按钮 | 功能 |
|------|------|
| 日报合并写作（主任版） | 合并多份日报生成汇总 |
| 竞品分析报告写作 | 生成竞品分析报告 |
| 自定义写作 | 自定义写作任务 |

### 配置生效机制
- 每次进入"应用端按钮配置"时自动刷新最新沉淀集列表
- 自动清理已删除的沉淀集引用
- 保存后对应用端立即生效
- 点击按钮 = 触发服务端执行该按钮下勾选的沉淀集 Replay
- **文档自动加载**：服务端从配置目录读取文件，自动添加到文档列表

## 8. Replay 意图分析

系统提供 AI 辅助的 Replay 意图分析功能：

- 分析录制的用户操作
- 确定用户的操作意图
- 在当前环境中找到最佳匹配目标
- 支持模糊匹配和功能匹配

## 9. 大纲缓存机制

### 缓存行为
| 场景 | 大纲缓存状态 |
|------|-------------|
| 工作台切换（前台↔后台） | **保持不变** |
| Replay 执行 | **保持不变** |
| 其他业务逻辑 | **保持不变** |
| Server 重启 | **清空** |
| 手动调用清空 API | **清空** |

### 设计说明
- 大纲默认会缓存在服务端内存中
- 除非关闭/重启 Server，否则大纲缓存不会被清空
- 在两个工作台间切换、Replay 等操作时，大纲展示不受影响
- 这样设计确保用户在操作过程中大纲保持稳定一致

### 手动清空
```bash
# API 方式清空大纲缓存
DELETE /api/outline/cache
```

## 10. 服务端 Replay API

### API 端点
| 端点 | 方法 | 说明 |
|------|------|------|
| `/api/multi/replay/config` | GET | 获取 Replay 目录配置 |
| `/api/multi/replay/config` | POST | 保存 Replay 目录配置 |
| `/api/multi/replay/execute` | POST | 执行沉淀集 Replay |

### 执行参数
```json
{
  "groupIds": ["group_id_1", "group_id_2"],
  "buttonLabel": "按钮名称",
  "dirPath": "可选：自定义目录路径"
}
```

### 返回结果
```json
{
  "ok": true,
  "buttonLabel": "按钮名称",
  "groupNames": ["沉淀集1", "沉淀集2"],
  "totalSteps": 5,
  "docsLoaded": [
    { "name": "文档1.txt", "source": "replay_auto_load" }
  ],
  "results": [
    { "action": "添加文档", "status": "done", "reason": "已加载" }
  ]
}
```

## 11. 数据持久化

| 文件 | 说明 |
|------|------|
| `data/precipitation-records.json` | 沉淀记录 |
| `data/precipitation-groups.json` | 沉淀集 |
| `data/multi-app-buttons.json` | 应用端按钮配置 |
| `data/replay-config.json` | Replay 目录配置 |

## 12. 必要说明

### 应用端执行
- 应用端只是用户交互界面，不直接执行复杂逻辑
- 点击按钮后调用服务端 API 执行 Replay
- 服务端从配置目录自动加载文件
- 执行结果和文档列表自动同步到应用端显示

### 数据共享
- 所有数据持久化在 `data/` 目录
- 前后台共享文档和沉淀数据
- 切换工作台不会丢失数据
- **文档列表前后端同步**：一处上传，两边都生效

### 大模型 Replay 泛化逻辑
当使用大模型沉淀模式进行 Replay 时：
1. 检查当前环境与录制时的内容是否一致
2. 如果内容不一致，**不会失败**
3. 而是给到相同的 prompt，让大模型执行动作
4. 依靠大模型的泛化能力适应新的内容
5. 执行完成后标记状态为 `done` 或 `pass`

### 自动化文件加载
- 后管端配置目录路径后，Replay 时自动加载文件
- 文本直读类型：`.txt`, `.md`, `.json`, `.html`, `.xml`, `.csv`
- 其他类型（含 `.docx`）按 base64 载入
- 文件加载后自动添加到文档列表
- 文档列表在应用端和后管端同步显示




