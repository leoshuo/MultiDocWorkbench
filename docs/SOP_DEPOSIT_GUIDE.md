# 沉淀与 Replay 详细指南（后端管理端）

版本：1.6.6  
更新日期：2026-01-30

## v1.6.6 重要更新

### 应用端执行逻辑简化

**变更**：移除所有针对"最终文档生成"沉淀的定制化处理

| 删除的逻辑 | 说明 |
|------------|------|
| 备份大纲数据 | 不再在 replay 前备份 `originalOutlineTemplate` |
| 检测跳过逻辑 | 不再检测并跳过"最终文档生成"沉淀 |
| 恢复大纲数据 | 不再在最终文档生成前恢复备份 |
| 特殊调用逻辑 | 不再单独调用 `openFinalPreview()` |

**统一执行路径**：
```
所有沉淀 → /api/replay/execute-section → 服务端统一处理
```

### 耗时统计功能

**新增**：应用端执行完成后显示耗时统计

| 时间范围 | 显示格式 |
|----------|----------|
| < 1秒 | `xxx 毫秒` |
| 1秒 ~ 60秒 | `x.x 秒` |
| >= 60秒 | `x 分 x 秒` |

**示例输出**：
```
⏱️ 耗时统计：12.3 秒
```

### Bug 修复

- **API 路径修复**：`/api/precipitation/record/:id` → `/api/precipitation/records/:id`
- **消除 404 错误**：修复沉淀状态更新时的 404 报错

---

## v1.6.5 重要更新

### 应用端与后管端完全一致

**变更**：应用端 Replay 现在直接调用服务端 API，与后管端行为100%一致

| 项目 | 说明 |
|------|------|
| 统一执行器 | 应用端按钮点击 → `/api/replay/execute-section` → 与后管端相同逻辑 |
| 无独立处理 | 应用端不再有任何独立的 Replay 处理代码 |
| 结果同步 | 两端执行结果完全相同（日志、状态、原因说明） |

### 摘要位置精准写入

**新增**：支持写入指定位置的摘要（不再始终写入第一个）

**字段来源**：
- `meta.destinations[].summaryIndex`
- `meta.targetSectionsDetail[].summaryIndex`  
- `meta.targetSummaries[].summaryIndex`

**示例**：
```json
{
  "targetSectionsDetail": [{
    "id": "2",
    "title": "（一）政治中心区防控工作情况",
    "summaryIndex": 1  // 写入第2个摘要
  }]
}
```

**自动扩展**：如果目标索引超出 summaries 数组长度，自动补充空摘要项

### 场景与大纲持久化

**新增**：切换工作台不再丢失大纲数据

| 缓存文件 | 说明 |
|----------|------|
| `data/outline-cache.json` | 大纲模板缓存 |
| `data/scenes-cache.json` | 场景数据缓存 |

**自动恢复**：服务启动时，如果缓存为空但 main 场景有模板，自动从场景恢复

### 大模型语义文档匹配

**增强**：LLM 模式支持语义匹配文档名和标题

- **语义匹配**：使用 `callQwenSemanticMatch` 进行模糊匹配
- **灵活上传**：从 replayDir 目录通过关键词或语义找到相似文件
- **中文优化**：`无人机111111.txt` 可匹配 `无人机--最新.txt`

---

## v1.6.4 重要更新

### 填入摘要替换逻辑

**变更**：填入摘要操作现在是**替换**而非**追加**

| 操作 | 旧行为（追加） | 新行为（替换） |
|------|---------------|---------------|
| 填入摘要 | 内容追加到现有摘要后面 | 内容直接替换现有摘要 |
| Replay 执行 | 每次执行内容累积 | 每次执行内容替换 |

**适用场景**：
- 需要更新摘要内容而非累积
- 多次 Replay 不会导致内容重复

### AI 执行指导增强

**新增**：支持计算类任务的智能执行

**计算类任务示例**：
```
【AI执行指导】
从文档中提取四类数值：预警调度次数、电台调度次数、视频巡检次数、实地检查次数
代入公式计算：总次数 = 预警调度 + 电台调度 + 视频巡检 + 实地检查
输出格式："政治中心区调度检查 XXX 次"
```

**AI 执行流程**：
1. 检测 `aiGuidance` 中的计算关键词（计算、公式、{{}}、次数等）
2. 从原始内容中提取数值
3. 按公式进行数学计算
4. 按指定格式输出结果

### Replay 智能跳过机制

**新增**：当 Replay 无法找到符合录制要求的输入源信息时，返回 `pass` 状态而非强制执行

**行为说明**：
- **pass 状态**：业务级跳过，区别于系统级 `fail`
- **目标保护**：pass 时目标位置内容保持不变，不会被错误覆盖
- **原因展示**：在两个工作台都显示跳过原因（如"未找到有效输入源"、"目标标题不存在"等）

### 沉淀校验模式

**新增**：每个沉淀可设置校验模式

| 模式 | 标识 | 行为 |
|------|------|------|
| **强校验** | 🔒 | 要求找到与录制时相似的内容特征（前后文、摘要等），未找到则 pass |
| **不校验** | 🔓 | 不做严格校验，努力找到目标位置并执行（默认） |

**设置方式**：在沉淀编辑弹窗中选择校验模式

### 统一沉淀编辑

- **弹窗编辑**：点击沉淀的"✏️ 编辑"按钮，弹出完整编辑弹窗（复用结束沉淀时的确认弹窗）
- **移除内联编辑**：不再支持对单个 section 的内联编辑/编译
- **保存替换**：编辑保存后直接替换原沉淀记录

---

## v1.6.3 重要修复

### 应用端与后管端 Replay 统一性

**问题**：应用端点击按钮执行沉淀集 Replay 结果与后管端不一致

**根因**：
1. dispatch API 响应格式处理错误：应用端检查 `dispatchRes?.result`，但 API 返回 `{ summary, detail, edits, usedModel }`
2. insert_to_summary 输入获取逻辑不完整：扩写类操作应从当前大纲获取摘要作为输入

**修复**：
- 正确处理 dispatch API 响应的 `usedModel`、`detail`、`edits` 字段
- insert_to_summary 支持从当前大纲动态获取目标标题的摘要内容
- 统一目标标题定位：同时支持 `targetIds` 和 `targetTitles` 匹配

---

## 1. 沉淀记录

每条沉淀由多条 Section 组成，支持以下操作：

| 操作 | 说明 |
|------|------|
| 拖拽排序 | 直接拖拽调整执行顺序 |
| 点击编号 | 修改执行顺序 |
| 编辑内容 | 名称与各字段均可编辑 |
| 删除 | 直接删除数据库记录 |

## 2. Section 结构

每条 Section 包含五部分：

| 字段 | 说明 | 可标记 |
|------|------|--------|
| 输入来源 | 操作的输入数据来源 | 必须/可选 |
| 动作执行 | 执行的具体动作 | 必须/可选 |
| 执行摘要 | 执行结果摘要 | 必须/可选 |
| 记录位置 | 输出写入位置（使用标题而非序号） | 必须/可选 |
| 复现方式 | 特殊按钮的复现策略 | - |

### 编辑要求
- 可对"输入来源/动作执行/执行摘要/记录位置"标记【必须/可选】
- 支持回车确认编辑
- 编辑完成后（名称除外）需经过大模型编译为 Replay Meta
- 编译后自动持久化到 `data/precipitation-records.json`

## 3. Replay 机制

### Replay 级别
| 级别 | 说明 |
|------|------|
| 沉淀级 Replay | 按 Section 顺序依次执行 |
| Section级 Replay | 单条执行 |
| 沉淀集 Replay | 执行沉淀集内所有沉淀的所有 Section |

### 执行状态
| 级别 | 状态 | 说明 |
|------|------|------|
| Section | `done` | 完全成功 |
| Section | `pass` | 泛化妥协但完成 |
| Section | `fail` | 失败（必须记录原因） |
| 沉淀 | `done` | 所有 Section 成功 |
| 沉淀 | `partial done` | 部分成功 |
| 沉淀 | `fail` | 失败 |

## 4. 双重沉淀模式与双记录机制

### Section 双记录结构

每个 Section 同时保存两份记录：

| 记录类型 | 字段 | 说明 | 用途 |
|----------|------|------|------|
| **大模型记录** | `llmScript` | 用户确认的结构化脚本解析结果 | 大模型 Replay 时使用 |
| **脚本记录** | `originalScript` | 系统自动录制的原始参数 | 脚本回退 Replay 时使用 |

#### llmScript 字段
```json
{
  "title": "填入摘要",
  "type": "insert_to_summary",
  "description": "从文档中提取指定内容填入大纲摘要",
  "contentDescription": "需要提取人员姓名信息",
  "contextBefore": "内部 网络安全保卫总队",
  "contextAfter": "每日晨会要报",
  "targetTitle": "二、具体清查情况",
  "aiGuidance": "提取选区内容后去除职务称谓仅保留姓名"
}
```

#### originalScript 字段
```json
{
  "action": "填入摘要",
  "buttonLabel": "填入摘要",
  "content": "操作记录：将内容预览中框选的文本...",
  "meta": { /* 原始元数据 */ }
}
```

### 大模型沉淀（默认）
- 允许泛化，适应不同场景
- **优先使用 llmScript 进行智能 Replay**
- 依靠大模型理解脚本意图并智能执行
- 失败时自动回退到 originalScript 脚本执行
- 适合需要灵活处理的场景

### 脚本沉淀
- 严格一致，精确复现
- 直接使用 originalScript 执行
- 不一致直接 `pass` 并报错原因
- 适合需要精确控制的场景

### Replay 优先级
```
1. 大模型模式 + 有 llmScript
   → 尝试大模型执行
   → 成功：标记 llm_done
   → 失败：回退到脚本执行

2. 脚本执行（或回退）
   → 使用 originalScript 执行
   → 成功：标记 script_done
   → 失败：
     - 大模型模式：标记 skipped（两者都失败）
     - 脚本模式：标记 fail
```

### 执行状态与结果显示（v1.6.3 更新）

| 状态 | 显示格式 | 说明 |
|------|----------|------|
| `llm_done` | LLM Replay Done | 大模型成功执行 |
| `llm_done` (兼容) | LLM Replay Done（兼容性执行，差异：...） | 有差异但成功执行 |
| `script_done` | Script Replay Done | 脚本执行成功 |
| `script_fallback` | Script Replay Done（大模型回退原因：...） | 大模型失败后回退到脚本 |
| `skipped` | Skipped | 大模型和脚本都失败，跳过此步骤 |
| `fail` | Failed | 完全失败（仅脚本模式） |

**结果反馈原则**：
- 大模型完全成功：只显示"LLM Replay Done"
- 大模型兼容性执行：显示差异内容
- 回退到脚本：显示大模型失败原因

### 切换方式
- 每条沉淀可独立切换"脚本沉淀/大模型沉淀"模式
- 切换后立即生效

## 5. 自动沉淀流程

```
1. 点击"自动沉淀"开始录制
   |
   v
2. 执行各种操作（点击按钮）
   - 每次按钮点击自动生成 Section
   - Section 包含完整的输入、动作、输出信息
   |
   v
3. 点击"结束沉淀"
   - 生成沉淀记录
   - 保存到 data/precipitation-records.json
   |
   v
4. 可选：编辑沉淀记录
   - 调整顺序
   - 编辑字段
   - 编译为 Replay Meta
```

### 自动沉淀记录原则

**核心原则：只记录按钮的 Replay 逻辑，不记录编辑框中的具体内容**

例如：操作调度中点击"执行指令"按钮时：
- 不记录：文本框中输入的具体内容
- 只记录：点击"执行指令"按钮的相关重要信息

### Section 记录四要素

| 要素 | 说明 | 示例 |
|------|------|------|
| **输入来源** | 用户基于什么类型的内容操作 | 记录该部分内容的类型、上下文信息 |
| **动作执行** | 用户输入了什么要求 | 用户的修改意图和指令 |
| **记录位置** | 回写作用在什么地方 | **使用标题定位，而非序号**（如"写入'项目背景'标题下的摘要"） |
| **执行摘要** | 结果输出了什么 | 执行结果的摘要信息 |

### 位置记录规范
- 正确：记录写入"项目背景"标题下的摘要
- 错误：记录写入第3个标题下的摘要
- 原因：使用标题可确保 Replay 时定位准确，不受顺序变化影响

## 6. 沉淀集管理 沉淀集管理

### 入口
点击"沉淀集列表"打开沉淀集管理面板

### 功能
| 操作 | 说明 |
|------|------|
| 新增 | 创建新的沉淀集 |
| 更新 | 修改沉淀集内容 |
| 重命名 | 修改沉淀集名称 |
| 删除 | 删除沉淀集 |
| Replay | 执行沉淀集内所有沉淀 |

### 合并沉淀
- 选择多条沉淀合并到某个沉淀集
- 沉淀集内的每条沉淀仍可单独编辑与 Replay

## 7. 应用端与后管端架构设计

### 核心理念
```
应用端（多文档处理工作台）     后管端（经验沉淀工作台）
     ↓ 用户交互界面                    ↓ 配置和执行中心
     ↓ 收集用户需求                    ↓ 配置沉淀集
     ↓ 展示执行结果                    ↓ 配置目录路径
                                      ↓ 执行 Replay 逻辑
```

### 设计说明
- **应用端**：只是用户交互的界面，收集用户需求，展示结果
- **后管端**：真正执行所有自动化脚本和大模型 Replay 逻辑的地方
- **服务端**：处理 Replay 执行、文件加载、数据持久化

### Replay 执行流程
```
1. 用户在应用端点击按钮
   ↓
2. 应用端调用服务端 /api/multi/replay/execute API
   ↓
3. 服务端从配置的目录自动加载文件
   ↓
4. 服务端执行沉淀集中的所有 Replay 步骤
   ↓
5. 服务端返回执行结果和加载的文档
   ↓
6. 应用端同步显示文档列表和执行结果
```

## 8. 应用端按钮配置

### 配置界面
- 左列：前台按钮列表
- 右列：沉淀集列表（可多选）
- **Replay 目录配置**：配置服务端自动加载文件的目录路径

### 配置流程
1. 选择要配置的前台按钮
2. 勾选关联的沉淀集（支持多选）
3. **配置 Replay 目录路径**（服务端可访问的绝对路径）
4. 点击保存
5. 保存成功后前台按钮即可触发对应沉淀集 Replay

### 目录配置说明
| 配置项 | 说明 |
|--------|------|
| 目录路径 | 服务端可访问的绝对路径（如 `C:\Documents` 或 `/home/user/docs`） |
| 自动加载 | Replay 时自动从目录读取文件 |

### 默认按钮
| 按钮 | 功能 |
|------|------|
| 日报合并写作（主任版） | 合并多份日报生成汇总 |
| 竞品分析报告写作 | 生成竞品分析报告 |
| 自定义写作 | 自定义写作任务 |

### 配置生效机制
- 每次进入"应用端按钮配置"时自动刷新最新沉淀集列表
- 自动清理已删除的沉淀集引用
- 保存后对应用端立即生效
- 点击按钮 = 触发服务端执行该按钮下勾选的沉淀集 Replay
- **文档自动加载**：服务端从配置目录读取文件，自动添加到文档列表

## 8. Replay 意图分析

系统提供 AI 辅助的 Replay 意图分析功能：

- 分析录制的用户操作
- 确定用户的操作意图
- 在当前环境中找到最佳匹配目标
- 支持模糊匹配和功能匹配

## 9. 大纲缓存机制

### 缓存行为
| 场景 | 大纲缓存状态 |
|------|-------------|
| 工作台切换（前台↔后台） | **保持不变** |
| Replay 执行 | **保持不变** |
| 其他业务逻辑 | **保持不变** |
| Server 重启 | **清空** |
| 手动调用清空 API | **清空** |

### 设计说明
- 大纲默认会缓存在服务端内存中
- 除非关闭/重启 Server，否则大纲缓存不会被清空
- 在两个工作台间切换、Replay 等操作时，大纲展示不受影响
- 这样设计确保用户在操作过程中大纲保持稳定一致

### 手动清空
```bash
# API 方式清空大纲缓存
DELETE /api/outline/cache
```

## 10. 服务端 Replay API

### API 端点
| 端点 | 方法 | 说明 |
|------|------|------|
| `/api/multi/replay/config` | GET | 获取 Replay 目录配置 |
| `/api/multi/replay/config` | POST | 保存 Replay 目录配置 |
| `/api/multi/replay/execute` | POST | 执行沉淀集 Replay |

### 执行参数
```json
{
  "groupIds": ["group_id_1", "group_id_2"],
  "buttonLabel": "按钮名称",
  "dirPath": "可选：自定义目录路径"
}
```

### 返回结果
```json
{
  "ok": true,
  "buttonLabel": "按钮名称",
  "groupNames": ["沉淀集1", "沉淀集2"],
  "totalSteps": 5,
  "docsLoaded": [
    { "name": "文档1.txt", "source": "replay_auto_load" }
  ],
  "results": [
    { "action": "添加文档", "status": "done", "reason": "已加载" }
  ]
}
```

## 11. 数据持久化

| 文件 | 说明 |
|------|------|
| `data/precipitation-records.json` | 沉淀记录 |
| `data/precipitation-groups.json` | 沉淀集 |
| `data/multi-app-buttons.json` | 应用端按钮配置 |
| `data/replay-config.json` | Replay 目录配置 |

## 12. 必要说明

### 应用端执行
- 应用端只是用户交互界面，不直接执行复杂逻辑
- 点击按钮后调用服务端 API 执行 Replay
- 服务端从配置目录自动加载文件
- 执行结果和文档列表自动同步到应用端显示

### 数据共享
- 所有数据持久化在 `data/` 目录
- 前后台共享文档和沉淀数据
- 切换工作台不会丢失数据
- **文档列表前后端同步**：一处上传，两边都生效

### 大模型 Replay 泛化逻辑
当使用大模型沉淀模式进行 Replay 时：
1. 检查当前环境与录制时的内容是否一致
2. 如果内容不一致，**不会失败**
3. 而是给到相同的 prompt，让大模型执行动作
4. 依靠大模型的泛化能力适应新的内容
5. 执行完成后标记状态为 `done` 或 `pass`

### 自动化文件加载
- 后管端配置目录路径后，Replay 时自动加载文件
- 文本直读类型：`.txt`, `.md`, `.json`, `.html`, `.xml`, `.csv`
- 其他类型（含 `.docx`）按 base64 载入
- 文件加载后自动添加到文档列表
- 文档列表在应用端和后管端同步显示




